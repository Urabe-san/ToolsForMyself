【原稿】タスク・ジョブ・プロセス・スレッドについて

一般的なパソコンでのタスク・ジョブ・プロセス・スレッドは以下の通り定義できると考えられます。
ここで当てはまらないパターンとしてはリアルタイムOSが相当します。

タスク＞ジョブ＞プロセス＞スレッド

プログラムが動作するハードウェアやOSによっては、
タスク≧ジョブまたはタスク＝ジョブ、ジョブ≧プロセスとなる場合があります。
シングルスレッドのプログラムではプロセス＝スレッドにもなります。

以下、Windowsに限定したときのプログラマ目線での解説になります。
(タスク、ジョブ、プロセス、スレッドの順では説明しません)

[Ctrl]+[Alt]+[Del]キーを押したとき、ロックやサインアウトと同時に[タスクマネージャー]が出てきます。
そして最初に出てくる一覧は[プロセス]単位で表示され、それぞれリソースの使用状況が確認できます。

直感的にタスクマネージャー見て感じることは、[プロセス]と言うのは実行されているプログラムなのではないかと言うことです。
そして多くの場合ではこの感覚は正しいと思います。

ではジョブとはなんでしょうか？
ジョブは基本的にはプロセスです。では言い方を分ける必要があるかと言うと「分ける必要がある」と言うことになります。
Windowsではほとんどの場合はジョブ＝プロセスです。
分ける必要がある場合はどんなときかと言うと、プロセスが、プロセスを起動してなおかつ呼び出されたプロセスの終了を待つ(または何らかの形でデータの同期をしている)場合です。
コマンドプロンプトの場合は「パイプ」も同じ状態だと言えます。
プロセスがプロセスを呼び出してもジョブとならない場合は非常に単純で、いわゆる「ランチャ」としてプロセス(プログラム)を起動した場合は子プロセスとして呼び出さないので、ジョブにはなりません。単に別ジョブを作成してを起動したことになります。

タスクマネージャーに話を戻すとプロセスと記載されているがジョブなのではと思うかもしれません。

これは推測ですが、ジョブで正しいと思いますが一部で表現できない場合があるためプロセスとしたのではないかと推測しています。

Windows11でタスクマネージャーをよく見ると、実行プロセスは「アプリ」であったり「バックグラウンドプロセス」でグルーピングされています。
※以前のバージョンのOSではこのようなグルーピングはされていなかったと思います、

そしてタスクマネージャーのプログラム内で情報は[プロセス]ごとに取得されているのは明らかなのですが、そのプロセスのしたに子プロセスが存在する場合にその情報を取得することは可能であっても表示に必要であるのか問われるとほとんどの場合はで不要かと思います。
それにタスクマネージャーで表示を[ジョブ]とした場合、ジョブの中で実行中のプロセスを階層で表示する必要が出てくるためそのままプロセスとして表示したほうが都合が良いものと思われます。
さらにプログラム起動直後には、「ジョブ≧プロセス」なのか「ジョブ＝プロセス」なのかOSは知る由もないため、プロセスに落ち着いたものと思います。

プログラマの視線では、最初に注目すべきはプロセスですし、ほとんどのプログラムでは開発やデバッグのときなどはプロセスしか意識する必要がありません。
また単体テストの場合はプロセス単位で行うものとなっています。
(結合テストではジョブ単位、最終的なテストまでにはタスク単位での動作確認が必要です。)

ジョブやプロセスの上位にあるタスクですが、これはWindowsでは「タスクスケジューラー」を起動して画面を見たほうが分かりやすいと思います。
タスクスケジューラーの[タスク]はまさにここで説明したいタスクです。
ずばり[タスク]はジョブの塊です。それが順次実行になるか並列実行になるかはここでは問われません。
また、タスクスケジューラーではバッチファイルを呼び出すことができます。
一般的にバッチファイルもプログラムとみなされる場合がありますが、タスクスケジューラー上では条件分岐などを記載できる「手順」に近いものと受け取ったほうが解釈しやすいです。

WindowsはマルチタスクOSで、同時に複数のタスクの起動ができます。

次にスレッドの話をします。
スレッドは本来はCPUレベルでの実行単位です。
プログラム＝プロセスとしたときに、[プロセス]は起動直後にかならず１つの[スレッド]を内包していて、CPUの実行単位のレベルでは[プロセス]＝[スレッド]として起動します。
[プロセス]が動作している[スレッド]が同じプロセスの別なスレッドを起動した場合は、プロセスに2つ以上のスレッドが存在することになります。

そして今まで[プロセス]についての記述をしていません。

[プロセス]は基本的に１つの実行ファイルと呼び出される動的ライブラリの実行単位です。
※ここでの「動的ライブラリ」はDLLやOCXなどのうち、OSの一部(Windows APIやシステムコールとして呼び出される)ではないもの

Windowsに限らずマルチタスク対応OSでは、[プロセス]は１つ以上の[スレッド]を持っていて、リソースとセットになります。
Windowsなどのプロテクトモードで動作するOSでは、[プロセス]から他の[プロセス]の[リソース]にはアクセスできません。
※プロテクトモードの話はここではしません。以前のインテルCPUで動作していたMS-DOS(PC-DOS)はリアルモードで動作します。
※特権で動作するプログラム場合は、メモリ上の他の[プロセス]自体や他の[プロセス]のリソースの中身を見ることができます。

[タスク]や[ジョブ]は個別にリソースを持ちません。
[スレッド]は[プロセス]が持つリソースを使います。[プロセス]が複数の[スレッド]を持つ場合(マルチスレッド)は[プロセス]のリソースを複数の[スレッド]から書き込みができます。
「スレッド間のデータの同期」とは言い換えればリソースの値の保護です。
リアルタイムでリソースの内容を知りたい場合は、Volatile変数としてアクセスすることにより「そのとき」のリソースの値を知ることができます。

リソースの値のロックして「書き込み」と「読み込み」を制限することによりリソースの内容の保証ができます。
ただし、複数のスレッドからリソースに対するアクセスがある場合は処理が遅延する可能性があり、ロックを解除する方法が失われた場合はデッドロックになります。
リソースにアクセスしようとした順番で処理する必要がある場合はロックのみでは解決できないため、リソースアクセスのIOのみをシングルスレッド用に振舞わせる必要もあります。


あまり知られてはいないものとして[ファイバ]があります。
[ファイバ]は[スレッド]の機能限定サブセットのようなものですが、制御は[プロセス]でのみ行えます。
CPUからは[ファイバ]と言う形では見えません。CPUは[スレッド]にのみ制御ができます。
そのためCPUからは[ファイバ]に対しての制御はできず、[プロセス]の中の[スレッド]からのみ制御できます。

話が変わりますが、最初に「リアルタイムOSは当てはまらない」と記載しました。
それはリアルタイムOSはプログラムの管理方法が違うためです。
OSによってはタスク＝スレッドとして解釈したほうが理解しやすい場合が多いです。
(実際にそのような管理方法で管理はしていません)
では[プロセス]はなにかと言うとリアルタイムOS自体が1つの「プロセス」になっていると考えると理解しやすいです。
※リアルタイムOS＝そのOSが動いているハードウェア自体と考えても差し支えないです。

シングルボードコンピュータ上のシングルタスクのリアルタイムOSである場合を例にすると、OS自体が１つの[スレッド]でCPUの利用を独占します。
この場合は実行したい処理＝プログラム＝プロセスとした場合
そして何らかの処理を行う場合は、実行したい[プロセス]をメモリ上に読み込んでから、[プロセス]終了時に実行する(戻る場所)を指定して自[プロセス]を「プログラム実行待ち」の状態におき、メモリ上に読み込んである[プロセス]をCPUに実行させます。この一連の動作を割り込み処理(interrupt process)とも言います。

ついでにスレッドと関係があるタイムスライスとランリストについても説明します。
※ランリストはWindowsの用語ではないかもしれません。GNUのランタイムの説明書の「リアルタイムスケジューリング」(https://www.gnu.org/software/libc/manual/html_node/Realtime-Scheduling.html)などには用語として登場しますがMicorosoftのマニュアルには見当たりません。

CPUでプログラムが実行される際には、プログラムを「CPUのスレッド」で実行させる必要があります。
[タイムスライス]はプログラムを「CPUのスレッド」に実行させるスケジュールを利用時間で分割する仕組みです。
実行待ちになっているリストはWindowsでの名称が見当たりませんでしたが、Linuxでは「ランリスト」との名称もあります。
※細かくは「時分割」されておらず、割り当てられた部分の実行が終わるまでは実行されます

Windows APIのSleep()やそのC#やVisualBasicのラッピング関数は大きな誤解をされているようです。
実はSleepはしてのミリ秒で実行を待つのではなく、指定したミリ秒の間に実行されるランリストに乗せられないだけです。
言い換えれば、「指定したミリ秒は実行されないこと」は保障されますが、「指定したミリ秒を待った後に確実に実行される」ことは保障されません。

